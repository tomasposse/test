<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>WebXR AR Sphere with Crazy Shader</title>
<style>
  html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: black; }
</style>
</head>
<body>
<button id="start-ar" style="position: absolute; top: 20px; left: 20px; z-index: 10;">
  Start AR
</button>
<script>
let xrSession = null;
let xrRefSpace = null;
let gl = null;
let program = null;
let sphereVAO = null;
let uTimeLoc, uProjLoc, uViewLoc;

document.getElementById("start-ar").onclick = () => {
  navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['local'] })
    .then(onSessionStarted);
};

if (navigator.xr) {
  navigator.xr.isSessionSupported('immersive-ar').then(supported => {
    if (!supported) alert("WebXR AR not supported");
  });
} else {
  alert("WebXR not available");
}

function onSessionStarted(session) {
  xrSession = session;

  const canvas = document.createElement('canvas');
  gl = canvas.getContext('webgl', { xrCompatible: true });
  document.body.appendChild(canvas);

  session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

  session.requestReferenceSpace('local').then(refSpace => {
    xrRefSpace = refSpace;
    initGL();
    session.requestAnimationFrame(onXRFrame);
  });
}

// GLSL shaders
const vsSource = `
attribute vec3 aPosition;
uniform mat4 uProjectionMatrix;
uniform mat4 uViewMatrix;
varying vec3 vPosition;
void main() {
  vPosition = aPosition;
  gl_Position = uProjectionMatrix * uViewMatrix * vec4(aPosition, 1.0);
}
`;

const fsSource = `
precision mediump float;
uniform float uTime;
varying vec3 vPosition;
void main() {
    vec2 uv = normalize(vPosition).xy;
    uv += 0.4 * sin(uv*3.0 + uTime);
    uv += 0.25 * cos(uv*7.0 - uTime*0.8);
    uv += 0.12 * sin(uv*11.0 + uTime*1.2);
    float angle = sin(length(uv)*4.5 - uTime);
    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
    uv = rot * uv;
    float localTime = uTime + sin(uv.x*8.0) * cos(uv.y*12.0);
    float coarse = sin(5.0*length(uv) - localTime);
    float fine = sin(80.0*uv.x + localTime) * cos(90.0*uv.y - localTime);
    float tear = fract(sin(150.0*uv.x*uv.y));
    float r = sin(coarse + fine + tear + localTime);
    float g = cos(coarse - fine - tear - localTime*1.3);
    float b = sin((coarse*1.2 + fine*0.8 + tear*2.0) - localTime*0.6);
    gl_FragColor = vec4(0.5 + 0.5 * vec3(r,g,b), 1.0) * smoothstep(1.0, 0.0, length(uv)*0.8);
}
`;

function initGL() {
  const vs = compileShader(gl.VERTEX_SHADER, vsSource);
  const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
  program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    return;
  }

  gl.useProgram(program);

  // Locate uniforms
  uTimeLoc = gl.getUniformLocation(program, 'uTime');
  uProjLoc = gl.getUniformLocation(program, 'uProjectionMatrix');
  uViewLoc = gl.getUniformLocation(program, 'uViewMatrix');

  initSphere();
}

function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

// Simple sphere buffer
function initSphere() {
  let positions = [];
  const latBands = 30, lonBands = 30, radius = 0.2;
  for (let lat=0; lat<=latBands; lat++) {
    let theta = lat * Math.PI / latBands;
    for (let lon=0; lon<=lonBands; lon++) {
      let phi = lon * 2 * Math.PI / lonBands;
      let x = radius * Math.sin(theta) * Math.cos(phi);
      let y = radius * Math.cos(theta);
      let z = radius * Math.sin(theta) * Math.sin(phi);
      positions.push(x, y, z);
    }
  }

  let indices = [];
  for (let lat=0; lat<latBands; lat++) {
    for (let lon=0; lon<lonBands; lon++) {
      let first = (lat * (lonBands+1)) + lon;
      let second = first + lonBands + 1;
      indices.push(first, second, first+1, second, second+1, first+1);
    }
  }

  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

  const idxBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

  const posLoc = gl.getAttribLocation(program, 'aPosition');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

  sphereVAO = { vertexCount: indices.length };
}

function onXRFrame(time, frame) {
  xrSession.requestAnimationFrame(onXRFrame);

  const pose = frame.getViewerPose(xrRefSpace);
  if (!pose) return;

  const glLayer = xrSession.renderState.baseLayer;
  gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

  gl.clearColor(0,0,0,0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  for (const view of pose.views) {
    const viewport = glLayer.getViewport(view);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

    gl.uniformMatrix4fv(uProjLoc, false, view.projectionMatrix);
    gl.uniformMatrix4fv(uViewLoc, false, view.transform.inverse.matrix);
    gl.uniform1f(uTimeLoc, time*0.001);

    gl.drawElements(gl.TRIANGLES, sphereVAO.vertexCount, gl.UNSIGNED_SHORT, 0);
  }
}
</script>
</body>
</html>
