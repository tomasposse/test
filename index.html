<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vanilla WebGL AR Shader</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:black; }
    canvas { display:block; width:100%; height:100%; }
    #video { display:none; }
  </style>
</head>
<body>
<video id="video" autoplay playsinline muted></video>
<canvas id="glcanvas"></canvas>
<script>
const video = document.getElementById("video");
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Setup shaders
const vsSource = `
attribute vec4 aPosition;
varying vec2 vUV;
void main() {
    vUV = aPosition.xy * 0.5 + 0.5;
    gl_Position = aPosition;
}
`;

const fsSource = `
precision mediump float;
uniform float uTime;
uniform sampler2D uVideo;
varying vec2 vUV;

void main() {
    vec2 uv = vUV;
    vec3 videoColor = texture2D(uVideo, uv).rgb;

    // 2: recursive warps with irrational scales
    uv += 0.4 * sin(uv*3.0 + uTime);
    uv += 0.25 * cos(uv*7.0 - uTime*0.8);
    uv += 0.12 * sin(uv*11.0 + uTime*1.2);

    // 3: local swirl
    float angle = sin(length(uv)*4.5 - uTime);
    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
    uv = rot * (uv - 0.5) + 0.5;

    // 4: local time
    float localTime = uTime + sin(uv.x*8.0) * cos(uv.y*12.0);

    // 5: multi-scale fields
    float coarse = sin(5.0*length(uv-0.5) - localTime);
    float fine = sin(80.0*uv.x + localTime) * cos(90.0*uv.y - localTime);

    // 6: micro fract tear
    float tear = fract(sin(150.0*uv.x*uv.y));

    // 9: separate RGB fields
    float r = sin(coarse + fine + tear + localTime);
    float g = cos(coarse - fine - tear - localTime*1.3);
    float b = sin((coarse*1.2 + fine*0.8 + tear*2.0) - localTime*0.6);

    vec3 shaderColor = 0.5 + 0.5 * vec3(r,g,b);

    // 10: blend shader with camera
    float mask = smoothstep(1.0, 0.0, length(uv-0.5)*1.5);
    vec3 color = mix(videoColor, shaderColor, mask);

    gl_FragColor = vec4(color,1.0);
}
`;

function loadShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }
    return shader;
}

const vs = loadShader(gl.VERTEX_SHADER, vsSource);
const fs = loadShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
gl.useProgram(program);

// Setup buffer
const posLoc = gl.getAttribLocation(program, 'aPosition');
const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1, 1, -1, -1, 1, 1, 1
]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uTimeLoc = gl.getUniformLocation(program, 'uTime');
const uVideoLoc = gl.getUniformLocation(program, 'uVideo');

// Setup video texture
const videoTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, videoTexture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// Animation loop
function render(){
    let time = performance.now() * 0.001;

    // update video texture
    if (video.readyState >= 2) {
        gl.bindTexture(gl.TEXTURE_2D, videoTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, video);
    }

    gl.uniform1f(uTimeLoc, time);
    gl.uniform1i(uVideoLoc, 0);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
}

// Start camera
navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
.then(stream => {
    video.srcObject = stream;
    video.play();
    render();
})
.catch(err => {
    console.error("Camera error:", err);
    document.body.innerHTML = "<h2 style='color:white'>ðŸš« Could not start camera:<br>"+err.message+"</h2>";
});
</script>
</body>
</html>
