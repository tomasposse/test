<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Crazy Shader</title>
<style>
  html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
  canvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const vsSource = `
attribute vec4 aPosition;
void main() {
    gl_Position = aPosition;
}
`;

const fsSource = `
precision mediump float;
uniform float uTime;

void main() {
    // 1: normalized
    vec2 uv = (gl_FragCoord.xy - vec2(640.0, 360.0)) / 360.0;

    // 2: recursive warps with irrational scales
    uv += 0.4 * sin(uv*3.0 + uTime);
    uv += 0.25 * cos(uv*7.0 - uTime*0.8);
    uv += 0.12 * sin(uv*11.0 + uTime*1.2);

    // 3: local swirl
    float angle = sin(length(uv)*4.5 - uTime);
    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
    uv = rot * uv;

    // 4: local time
    float localTime = uTime + sin(uv.x*8.0) * cos(uv.y*12.0);

    // 5: multi-scale fields
    float coarse = sin(5.0*length(uv) - localTime);
    float fine = sin(80.0*uv.x + localTime) * cos(90.0*uv.y - localTime);

    // 6: micro fract tear
    float tear = fract(sin(150.0*uv.x*uv.y));

    // 9: separate RGB fields
    float r = sin(coarse + fine + tear + localTime);
    float g = cos(coarse - fine - tear - localTime*1.3);
    float b = sin((coarse*1.2 + fine*0.8 + tear*2.0) - localTime*0.6);

    // 10: fade to dark
    gl_FragColor = vec4(
        0.5 + 0.5 * vec3(r,g,b),
        1.0
    ) * smoothstep(1.0, 0.0, length(uv)*0.8);
}

`;

function loadShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }
    return shader;
}

const vs = loadShader(gl.VERTEX_SHADER, vsSource);
const fs = loadShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

gl.useProgram(program);

const posLoc = gl.getAttribLocation(program, 'aPosition');
const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1, 1, -1, -1, 1, 1, 1
]), gl.STATIC_DRAW);

gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const uTimeLoc = gl.getUniformLocation(program, 'uTime');

function render(){
    let time = performance.now() * 0.001;
    gl.uniform1f(uTimeLoc, time);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
